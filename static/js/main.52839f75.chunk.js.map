{"version":3,"sources":["components/NavBar.js","components/context.js","components/methodList.js","components/Mount.js","components/TabBar.js","components/OldNewLifeCycle.js","components/data.js","App.js","serviceWorker.js","index.js"],"names":["withStyles","root","display","justifyContent","alignContent","props","classes","react_default","a","createElement","className","AppBar_default","position","Toolbar_default","Typography_default","variant","color","context","React","createContext","Provider","Consumer","theme","width","boxShadow","backgroundColor","palette","background","paper","contentList","content","map","item","index","ListItem_default","button","key","ListItemText_default","primary","List_default","component","heading","fontSize","typography","pxToRem","secondaryHeading","text","secondary","icon","verticalAlign","height","details","alignItems","column","flexBasis","helper","borderLeft","concat","divider","padding","spacing","unit","link","main","textDecoration","&:hover","phase","panel","data","mount","methods","update","unmount","ExpansionPanel_default","ExpansionPanelSummary_default","expandIcon","ExpandMore_default","name","times","ExpansionPanelDetails_default","components_methodList","classNames","Card_default","card","style","margin","CardContent_default","src","process","img","alt","Divider_default","TabContainer","_ref","children","dir","TabBar","state","value","handleChange","event","_this","setState","handleChangeIndex","_this$props","this","Tabs_default","onChange","indicatorColor","textColor","Tab_default","label","lib_default","axis","direction","onChangeIndex","components_Mount","Component","withTheme","OldNewLifeCycle","open","Object","defineProperty","target","checked","_this2","FormGroup_default","row","FormControlLabel_default","control","Switch_default","switchBase","iOSSwitchBase","bar","iOSBar","iOSIcon","iconChecked","iOSIconChecked","iOSChecked","disableRipple","onClick","handleClick","colorSwitchBase","purple","&$colorChecked","& + $colorBar","colorBar","colorChecked","&$iOSChecked","common","white","& + $iOSBar","transition","transitions","create","duration","shortest","easing","sharp","transform","opacity","border","borderRadius","marginTop","marginLeft","borderColor","grey","shadows","lifeCycleData","App","oldNew","bool","Fragment","components_NavBar","components_OldNewLifeCycle","objectSpread","components_TabBar","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.52839f75.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\n\nconst styles = {\n    root: {\n        display: 'flex',\n        justifyContent:'center',\n        alignContent: 'center'\n    }\n};\n\nfunction NavBar(props) {\n    const { classes } = props;\n    return (\n        <div className={classes.root}>\n            <AppBar position=\"static\">\n                <Toolbar className={classes.root}>\n                    \n                    <Typography variant=\"h6\" color=\"inherit\">\n                       React's Component Life Cycle\n                    </Typography>\n                </Toolbar>\n            </AppBar>\n        </div>\n    );\n}\n\nNavBar.propTypes = {\n    classes: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles)(NavBar);\n","import React from 'react';\n\n\nconst context = React.createContext();\n\n\nexport const Provider = context.Provider;\nexport const Consumer = context.Consumer;","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\n\n\nconst styles = theme => ({\n    root: {\n        width: '100%',\n        boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.2), 0px 4px 5px 0px rgba(0,0,0,0.14), 0px 1px 10px 0px rgba(0,0,0,0.12)',\n        backgroundColor: theme.palette.background.paper,\n    },\n});\n\n\nfunction methodList(props) {\n    const { classes, content } = props;\n\n    var contentList = content.map((item, index) => {\n        return (\n            \n            <ListItem button key={index} >\n                    <ListItemText primary={item} />\n                </ListItem>\n        )\n    });\n\n    return (\n        <div className={classes.root} >\n            \n            <List component=\"nav\">\n                {contentList}\n            </List>\n        </div>\n    );\n}\n\nmethodList.propTypes = {\n    classes: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles)(methodList);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport classNames from 'classnames';\nimport ExpansionPanel from '@material-ui/core/ExpansionPanel';\nimport ExpansionPanelDetails from '@material-ui/core/ExpansionPanelDetails';\nimport ExpansionPanelSummary from '@material-ui/core/ExpansionPanelSummary';\nimport Typography from '@material-ui/core/Typography';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport Divider from '@material-ui/core/Divider';\nimport Card from '@material-ui/core/Card';\nimport CardContent from '@material-ui/core/CardContent';\n\nimport { Consumer } from './context';\nimport MethodList from './methodList';\n\nconst styles = theme => ({\n    root: {\n        width: '100%',\n    },\n    heading: {\n        fontSize: theme.typography.pxToRem(15),\n    },\n    secondaryHeading: {\n        fontSize: theme.typography.pxToRem(15),\n        color: theme.palette.text.secondary,\n    },\n    icon: {\n        verticalAlign: 'bottom',\n        height: 20,\n        width: 20,\n    },\n    details: {\n        alignItems: 'center',\n    },\n    column: {\n        flexBasis: '100%',\n    },\n    helper: {\n        borderLeft: `2px solid ${theme.palette.divider}`,\n        padding: `${theme.spacing.unit}px ${theme.spacing.unit * 2}px`,\n    },\n    link: {\n        color: theme.palette.primary.main,\n        textDecoration: 'none',\n        '&:hover': {\n            textDecoration: 'underline',\n        },\n    },\n});\n\nfunction Mount(props) {\n    const { classes, phase } = props;\n    let path;\n\n    const panel = (\n        <Consumer>\n            {\n                (data) => {\n                    \n                    if(phase === 'mount'){\n                        path = data.mount.methods;\n                    } else if (phase === 'update') {\n                        path = data.update.methods;\n                    }else {\n                        path = data.unmount.methods;\n                    }\n                    var panelList = path.map((item, index) => {\n\n                        return (\n                            <ExpansionPanel key={index}>\n\n                                <ExpansionPanelSummary expandIcon={<ExpandMoreIcon />}>\n                                    <div className={classes.column}>\n                                        <Typography className={classes.heading}>{item.name}</Typography>\n                                    </div>\n                                    <div className={classes.column}>\n                                        <Typography className={classes.secondaryHeading}>{item.times}</Typography>\n                                    </div>\n                                </ExpansionPanelSummary>\n\n                                <ExpansionPanelDetails className={classes.details}>\n                                    {/* <div className={classes.column} /> */}\n                                    <div className={classes.column}>\n                                        <MethodList content={item.content} />\n                                    </div>\n                                    <div className={classNames(classes.column)}>\n                                        <Card className={classes.card} style={{ width: '80%', 'margin':'0 12%'}}>\n                                            <CardContent style={{padding:'0px'}}>\n                                                <img src={process.env.PUBLIC_URL + item.img} alt=\"constructor\" style={{ width: '100%', display: 'block'}}/>\n                                            </CardContent>\n                                        </Card>\n                                        \n                                    </div>  \n                                </ExpansionPanelDetails>\n\n                                <Divider />\n\n                            </ExpansionPanel>\n                        )\n\n                    })\n                    return panelList;\n                }\n            }\n        </Consumer>\n    );\n    const mount = (<div style={{ margin: \"20px auto\", fontSize: '14px' }}>\n                        A component mounts when it is created and first inserted into the DOM i.e when it is rendered for the first time. The methods that are available during this period are:\n                    </div>);\n    const update = (<div style={{ margin: \"20px auto\", fontSize: '14px' }}>\n                        Components do not always remain in the same state after mounting. Sometimes the underlying props could change and the component has to be re-rendered. The updating lifecycle methods give you control over when and how this updating should take place.\n                        There are five updating lifecycle methods and they are called in the order they appear below:\n                    </div>);\n\n    const unmount = (<div style={{ margin: \"20px auto\", fontSize: '14px' }}>\n                        Components do not always stay in the DOM. Sometimes they have to be removed due to changes in state or something else. The unmounting method will help us handle unmounting of components. We say method because there is just one method as at React 16.\n                    </div>);\n    return (\n\n        <div className={classes.root}>\n\n            {\n                phase === 'mount' ? mount :\n                phase === 'update'? update :\n                phase === 'unmount' &&  unmount \n\n            }\n                \n            {\n                panel\n            }\n        </div>\n    );\n}\n\nMount.propTypes = {\n    classes: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles)(Mount);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport SwipeableViews from 'react-swipeable-views';\nimport AppBar from '@material-ui/core/AppBar';\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\n\nimport Mount from './Mount';\n\n\nfunction TabContainer({ children, dir }) {\n    return (\n        <Typography component=\"div\" dir={dir} style={{ padding: 8 * 3 }}>\n            {children}\n        </Typography>\n    );\n}\n\nTabContainer.propTypes = {\n    children: PropTypes.node.isRequired,\n    dir: PropTypes.string.isRequired,\n};\n\nconst styles = theme => ({\n    root: {\n        backgroundColor: theme.palette.background.paper,\n        width: 500,\n    },\n});\n\nclass TabBar extends React.Component {\n    state = {\n        value: 0,\n    };\n\n    handleChange = (event, value) => {\n        this.setState({ value });\n    };\n\n    handleChangeIndex = index => { \n        this.setState({ value: index });\n    };\n\n    render() {\n        const { classes, theme } = this.props;\n\n        return (\n            <div className={classes.root} style={{ width: '80%',margin:'30px auto'}}>\n                <AppBar position=\"static\" color=\"default\">\n                    <Tabs\n                        value={this.state.value}\n                        onChange={this.handleChange}\n                        indicatorColor=\"primary\"\n                        textColor=\"primary\"\n                        variant=\"fullWidth\">\n\n                        <Tab label=\"Mount\" />\n                        <Tab label=\"Update\" />\n                        <Tab label=\"Unmount\" />\n                    </Tabs>\n                </AppBar>\n                <SwipeableViews\n                    axis={theme.direction === 'rtl' ? 'x-reverse' : 'x'}\n                    index={this.state.value}\n                    onChangeIndex={this.handleChangeIndex}>\n\n                    <TabContainer dir={theme.direction}><Mount phase='mount'/></TabContainer>\n                    <TabContainer dir={theme.direction}><Mount phase='update' /></TabContainer>\n                    <TabContainer dir={theme.direction}><Mount phase='unmount' /></TabContainer>\n                </SwipeableViews>\n            </div>\n        );\n    }\n}\n\nTabBar.propTypes = {\n    classes: PropTypes.object.isRequired,\n    theme: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles, { withTheme: true })(TabBar);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport purple from '@material-ui/core/colors/purple';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\n\nconst styles = theme => ({\n    colorSwitchBase: {\n        color: purple[300],\n        '&$colorChecked': {\n            color: purple[500],\n            '& + $colorBar': {\n                backgroundColor: purple[500],\n            },\n        },\n    },\n    colorBar: {},\n    colorChecked: {},\n    iOSSwitchBase: {\n        '&$iOSChecked': {\n            color: theme.palette.common.white,\n            '& + $iOSBar': {\n                backgroundColor: '#52d869',\n            },\n        },\n        transition: theme.transitions.create('transform', {\n            duration: theme.transitions.duration.shortest,\n            easing: theme.transitions.easing.sharp,\n        }),\n    },\n    iOSChecked: {\n        transform: 'translateX(15px)',\n        '& + $iOSBar': {\n            opacity: 1,\n            border: 'none',\n        },\n    },\n    iOSBar: {\n        borderRadius: 13,\n        width: 42,\n        height: 26,\n        marginTop: -13,\n        marginLeft: -21,\n        border: 'solid 1px',\n        borderColor: theme.palette.grey[400],\n        backgroundColor: theme.palette.grey[50],\n        opacity: 1,\n        transition: theme.transitions.create(['background-color', 'border']),\n    },\n    iOSIcon: {\n        width: 24,\n        height: 24,\n    },\n    iOSIconChecked: {\n        boxShadow: theme.shadows[1],\n    },\n});\n\nclass OldNewLifeCycle extends React.Component {\n    state = {\n        open: true,\n        \n    };\n\n    handleChange = name => event => {\n        this.setState({ [name]: event.target.checked });\n    };\n\n    render() {\n        const { classes } = this.props;\n\n        return (\n            <FormGroup row style={{ width: '360px', margin: '20px auto', }}>\n                <FormControlLabel\n                    control={\n                        <Switch\n                            classes={{\n                                switchBase: classes.iOSSwitchBase,\n                                bar: classes.iOSBar,\n                                icon: classes.iOSIcon,\n                                iconChecked: classes.iOSIconChecked,\n                                checked: classes.iOSChecked,\n                            }}\n                            disableRipple\n                            checked={this.state.open}\n                            onChange={this.handleChange('open')}\n                            onClick={() => this.props.handleClick(this.state.open)}\n                            value=\"open\"\n                        />\n                    }\n                    label={this.state.open ? \"Old Life Cycle (less than 16.3 version)\" : \"New Life Cycle (16.3+ version)(IN-PROGRESS)\"}\n                />\n            </FormGroup>\n        );\n    }\n}\n\nOldNewLifeCycle.propTypes = {\n    classes: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles)(OldNewLifeCycle);\n","\n\n\n const lifeCycleData = {\n                        mount: {\n                            methods: [\n                                {\n                                    name: 'constructor()',\n                                    times:'Call One Time in Mount phase',\n                                    content:[\n                                        'In this phase the React component prepares for the upcoming tough journey, by setting up the initial states and default props, if any.',\n                                    ],\n                                    img:'./assets/img/mount/constructor.png'\n\n                                },\n                                {\n                                    name: 'componentWillMount()',            \n                                    times: 'Call One Time in Mount phase',\n                                    content: [\n                                        '🚨componentWillMount will be deprecated in React 16.3.',\n                                        'The componentWillMount method is called right before a component mounts or the render method is called. The truth is that you might hardly make use of this method in your React application.',\n                                        'The componentWillMount method sits between the constructor method and the render method which puts it in a very odd position. Since it’s before the render method, it can be used to set the default configuration for a component, but this is mostly done using the constructor method. And since nothing changes between these two methods, there will be no need to set the configuration again.',\n                                        'Also, the render method has not been called at this point so nothing can be done with the DOM of the component since it has not been mounted. Some might think that this is the right place to make API calls for client-side rendering but this should not be done. API calls are asynchronous and the data might not be returned before the render method gets called. This means that the component might render with empty data at least once.',\n                                        'one good way to make use of this method is to perform any setup that can be done at runtime, for instance connecting to external APIs like Firebase. This setup should typically be done at the highest level of your component, like your root component, so the majority of your components will likely not make use of this method.',\n\n                                    ],\n                                    img: './assets/img/mount/componentWilllMount.png'\n\n                                },\n                                {\n                                    name: 'render()',\n                                    times: 'Call during mount and update phase',\n                                    content: [\n                                        'mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.'\n                                    ],\n                                    img: './assets/img/mount/render.png'\n\n                                },\n                                {\n                                    name: 'componentDidMount()',\n                                    times: 'Call One Time in Mount phase',\n                                    content: [\n                                        'This method is available after the component has mounted. That is, after the HTML from render has finished loading. It is called once in the component life cycle and it signals that the component and all its sub-components have rendered properly.',\n                                        'This is the best place to make API calls since, at this point, the component has been mounted and is available to the DOM. Generally, componentDidMount is a good place to do all the setup you couldn’t have done without the DOM. ',\n                                        'So here is a bunch of things you can do with this method:: Connect a React app to external applications, such as web APIs or JavaScript frameworks, Set Timers using using setTimeout or setInterval, Add event listeners. Draw on an element you just rendered.',\n                                    ],\n                                    img: './assets/img/mount/componentDidMount.png'\n\n                                },\n                            ]\n                        },\n\n                        update:{\n                            methods: [\n                                {\n                                    name: 'componentWillReceiveProps()',\n                                    times: 'Call Every Time in update phase',\n                                    content: [\n                                        '🚨componentWillReceiveProps is set to be deprecated in React 16.3',\n                                        'Props are externally passed in to a component by its parent component. Sometimes these props are hooked to the state of the parent component. So if the state of the parent component changes, the props passed to the component changes and it has to be updated. If the props are tied to the state of the component, a change in it will mean a change in the state of the component.',\n                                        'componentWillReceiveProps is a method that is called before a component does anything with the new props. This method is called with the new props passed as an argument. Here, we have access to the next set of props and the present ones. Therefore, using this method, we can compare the present props with the new ones and check if anything has really changed.',\n                                        '🚨React may call this method even though nothing has really changed so make sure to make a comparison. If nothing has changed, there will be no need to change the state of the component. But if it has changed, then this change can be acted upon.',\n                                        'In the example , this.state.number will only be updated if the new number is different from the previous one. So if there’s no difference then the state is not updated.'\n                                    ],\n                                    img: './assets/img/update/componentWillReceiveProps.png'\n\n                                },\n                                {\n                                    name: 'shouldComponentUpdate()',\n                                    times: 'Call Every Time in update phase',\n                                    content: [\n                                            'This method is called before the component re-renders after receiving a new set of props or there’s a new state. We can see that it receives two arguments, the next props, and the next state. The default behavior is for a component to re-render once there’s a change of state of props.',\n                                            'shouldComponentUpdate is used to let React know that a component’s output is not affected by a change of props or state in the component and thus should not re-render. It returns either a true or false value. If it returns true, the component will go ahead and do what it always does, re-render the component. If it returns false then the component will not update. Note that this does not prevent child components from re-rendering when their state changes.',\n                                            'The best way to use this method is to have it return false and hence the component will not update under certain conditions. If those conditions are met, then the component does not update.',\n                                            '🚨 shouldComponentUpdate is a great place to improve the performance of a component because it can help to prevent unnecessary re-rendering. However, it is advised not to use this method for deep equality checks or JSON.stringify as this is very inefficient and may harm performance.'\n                                    ],\n                                    img: './assets/img/update/shouldComponentUpdate.png'\n\n                                },\n                                {\n                                    name: 'componentWillUpdate()',\n                                    times: 'Call Every Time in update phase',\n                                    content: [\n                                        '🚨componentWillUpdate method is set to be deprecated in React 16.3.',\n                                        'componentWillUpdate is the method that can be used to perform preparation before re-rendering occurs. You cannot call this.setState in this method.',\n                                        'One major thing that can be done with this method is to interact with things outside of the React architecture. Also, if you need to do any non-React setup before a component renders such as interacting with an API or checking the window size, componentWillUpdate can be used.',\n                                        'Another time to use this method is if you are using shouldComponentUpdate and need to do something when the props change. In this scenario, it is preferable to use it instead of componentWillReceiveProps and it will be called only when the component will actually be re-rendered. However, if you need state to change in response to change in props, use componentWillReceiveProps instead.',\n                                        'While it can be used to perform animations and other effects, it should not be done as this method might be called multiple times before the component is actually re-rendered.'\n\n                                    ],\n                                    img: './assets/img/update/componentWillUpdate.png'\n\n                                },\n                                {\n                                    name: 'render()',\n                                    times: 'Call Every Time in Mount & update phase',\n                                    content: [\n                                        'mounts the component onto the browser. This is a pure method, which means it gives the same output every time the same input is provided.'\n                                    ],\n                                    img: './assets/img/mount/render.png'\n\n                                },\n                                {\n                                    name: 'componentDidUpdate()',\n                                    times: 'Call Every Time in update phase',\n                                    content: [\n                                        'componentDidUpdate is called after any rendered HTML has finished loading. It receives two arguments, the props and state of the component before the current updating period began.',\n                                        'componentDidUpdate is the best place to perform interaction with non-React environment like the browser or making HTTP requests. This should be done as long as you compare the current props to the previous props to avoid unnecessary network requests.'\n                                    ],\n                                    img: './assets/img/update/componentDidUpdate.png'\n\n                                },\n                            ]\n                        },\n\n                        unmount: {\n                            methods: [\n                                {\n                                    name: 'componentWillUnmount()',\n                                    times: 'Call Every Time in unmount phase',\n                                    content: [\n                                       'This is the only unmounting method. componentWillUnmount is called right before a component is removed from the DOM. This is where you can perform any cleanups that should be done such as invalidating timers, canceling network requests, removing event listeners or canceling any subscriptions made in componentDidMount.'\n                                    ],\n                                    img: './assets/img/unmount/componentWillUnmount.png'\n\n                                },\n                                {\n                                    name: 'componentDidCatch()',\n                                    times: 'Call Every Time in unmount phase',\n                                    content: [\n                                        '🚨This lifecycle method was added in React 16 and is used in error boundaries.',\n                                        'A component becomes an error boundary if it defines the componentDidCatch method. In this method, this.setState can be called and used to catch an unhandled JavaScript error in a child component tree and display a fallback UI instead of the component that crashed. These errors are caught during rendering, in lifecycle methods, and in constructors of the whole tree below them.',\n                                        'This is to ensure that an error in a child component does not break the whole app.',\n                                        'It is important to note that this method only catches errors in child components and not in the component itself.',\n                                        'This method has two parameters. The first is the actual error thrown. The second parameter is an object with a componentStack property containing the component stack trace information. With these parameters, you can set the error info in state and return an appropriate message in its render method or log to a reporting system',\n                                        \n                                    ],\n                                    img: './assets/img/unmount/componentDidCatch.png'\n\n                                },\n                            ]\n                        }\n\n                    };\n\nexport default lifeCycleData;","import React, { Component } from 'react';\nimport NavBar from './components/NavBar';\nimport TabBar from './components/TabBar'; \nimport OldNewLifeCycle from './components/OldNewLifeCycle';\n\nimport { Provider } from './components/context';\nimport lifeCycleData from './components/data';\n\nclass App extends Component {\n  \n  state = {\n    ...lifeCycleData,\n    oldNew:false\n  };\n  handleClick= (bool) => {\n    // console.log('clicked',bool)\n    this.setState({\n      oldNew: bool\n    })\n  }\n  render() {\n    return (\n      <>\n\n        <NavBar />\n        <OldNewLifeCycle handleClick={this.handleClick}/>\n        <Provider value={{ ...this.state }}>\n          {\n            this.state.oldNew === false && <TabBar  />\n          }\n        </Provider>\n      </>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}